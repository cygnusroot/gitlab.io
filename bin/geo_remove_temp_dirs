#!/usr/bin/env ruby
require 'rubygems'
require 'bundler/setup'
require 'optparse'

GEO_LICENSE_ERROR_TEXT     = 'GitLab Geo is not supported with this license. Please contact sales@gitlab.com.'.freeze
IGNORABLE_NAMESPACE_PREFIX = '@'.freeze
DIR_PATTERN                = "*_#{'[[:xdigit:]]' * 14}.*git".freeze
NULL_SEPERATOR             = "\u0000".freeze

class UtilityOptionParser
  def self.parse(argv)
    options = { remove: false }

    op = OptionParser.new
    op.banner = 'GitLab Geo: Remove previous old-style temporary repository directories from a Geo secondary'
    op.separator ''
    op.separator 'Usage: ./geo_remove_temp_dirs [options]'
    op.separator ''
    op.separator 'By default will perform a dryrun - use `--remove` to delete the directories.'
    op.separator ''
    op.on('--dryrun', 'Perform a dryrun, simply scanning the repositories (default)') { options[:remove] = false }
    op.on('--list-shards', 'List available shards') { options[:list_shards] = true }
    op.on('--prompt', 'Ask whether to delete or not') { options[:prompt] = true }
    op.on('--remove', 'Permantely deletes the temporary directories') { options[:remove] = true }
    op.on('--shard NAME',  'Specify the shard name to check (leave empty to scan all shards)') do |name|
      options[:shard] = name
    end

    op.separator ''
    op.on('-h', '--help', 'Usage help') do
      puts op.to_s
      exit
    end
    op.separator ''

    op.parse!(argv)

    options
  end
end

def remove_repository_temp_dirs(shards, options)
  abort GEO_LICENSE_ERROR_TEXT unless Gitlab::Geo.license_allows?
  abort 'This is not a secondary node' unless Gitlab::Geo.secondary?

  removal_list = []

  puts "\nShards to scan: #{shards.size}"

  shards.each do |shard|
    unless Gitlab::Geo::ShardHealthCache.healthy_shard?(shard.name)
      puts "!!Shard named '#{shard.name}' is unhealthy, skipping: #{shard.path}"
      next
    end

    puts "\nScanning shard '#{shard.name}' : #{shard.path} ..."

    # old-style temp directories end with an underscore followed by a 14 character hex number
    IO.popen(%W(find #{shard.path} -mindepth 1 -type d -name #{DIR_PATTERN} -print0)) do |find|
      find.each_line(NULL_SEPERATOR) do |path|
        path.chomp!(NULL_SEPERATOR)
        repo_with_namespace = path
          .sub(shard.path, '')
          .sub(%r{^/*}, '')
          .chomp('.git')
          .chomp('.wiki')

        next unless repo_with_namespace =~ /_[[:xdigit:]]{14}\z/
        next if repo_with_namespace.start_with?("#{IGNORABLE_NAMESPACE_PREFIX}")
        next if Project.where_full_path_in([repo_with_namespace]).exists?
        next if File.file?(path)

        removal_list << path
        puts "Can be removed: #{path}"
      end
    end
  end

  puts ''
  puts '------------------------------------------------------------------------------'
  puts "Shards scanned: #{shards.size}"
  puts "Directories that can be removed: #{removal_list.size}"
  puts '------------------------------------------------------------------------------'

  perform_removals(removal_list, options) unless removal_list.empty?
end

def perform_removals(list, options)
  if options[:prompt]
    puts "Do you wish to delete the directories (yes/no)?"
    answer = gets.chomp
    options[:remove] = (answer == 'yes')
    puts "Nothing will be deleted" unless options[:remove]
  end

  if options[:remove]
    error_list = []

    puts ''
    list.each do |path|
      begin
        FileUtils.remove_dir(path)
        puts "Removed...#{path}"
      rescue
        puts "Cannot remove #{path}"
        error_list << path
      end
    end

    unless error_list.empty?
      puts '------------------------------------------------------------------------------'
      puts "Errors during deletion: #{error_list.size}"
      puts 'The following paths were unable to be removed:'
      error_list.each { |path| puts path }
    end
  end
end

def list_shards
  shards = StorageShard.all

  shards.each do |shard|
    health = Gitlab::Geo::ShardHealthCache.healthy_shard?(shard.name) ? 'Healthy  ' : 'Unhealthy'
    puts "#{health} : #{shard.name} : #{shard.path}"
  end

  exit
end

if $0 == __FILE__
  options = UtilityOptionParser.parse(ARGV)

  # We load rails environment / initializers only here to get faster command line startup when `--help` and `--version`
  puts "Loading Rails..."
  require File.join(File.expand_path(File.dirname(__FILE__)), '..', 'config', 'environment')

  list_shards if options[:list_shards]

  shards = StorageShard.all

  if options[:shard]
    shards.select! { |shard| shard.name == options[:shard] }
    abort "Shard named '#{options[:shard]}' does not exist" if shards.empty?
  else
    shards.uniq! { |shard| shard.path }
  end

  style = options[:remove] ? 'SCAN and DELETION' : (options[:prompt] ? 'SCAN and PROMPT' : 'DRYRUN')
  puts "Will perform a #{style}..."
  remove_repository_temp_dirs(shards, options)
end
