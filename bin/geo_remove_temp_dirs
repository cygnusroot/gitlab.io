#!/usr/bin/env ruby
require 'rubygems'
require 'bundler/setup'
require 'optparse'

GEO_LICENSE_ERROR_TEXT     = 'GitLab Geo is not supported with this license. Please contact sales@gitlab.com.'.freeze
IGNORABLE_NAMESPACE_PREFIX = '@'.freeze

class UtilityOptionParser
  def self.parse(argv)
    options = { remove: false }

    if File.exist?('../config/environment.rb')
      options[:rails_root] = '..'
    elsif File.exist?('./config/environment.rb')
      options[:rails_root] = '.'
    else
      puts "This utility must be run from with the Rails application directory"
      exit
    end

    op = OptionParser.new
    op.banner = 'GitLab Geo: Remove previous old-style temporary repository directories from a Geo secondary'
    op.separator ''
    op.separator 'Usage: ./geo_remove_temp_dirs [options]'
    op.separator ''
    op.separator 'By default will perform a dryrun - use `--remove` to delete the directories.'
    op.separator ''
    op.on('--dryrun', 'Perform a dryrun, simply scanning the repositories (default)') { options[:remove] = false }
    op.on('--list-shards', 'List available shards') { options[:list_shards] = true }
    op.on('--remove', 'Permantely deletes the temporary directories') { options[:remove] = true }
    op.on('--shard NAME',  'Specify the shard name to check (leave empty to scan all shards)') do |name|
      options[:shard] = name
    end

    op.separator ''
    op.on('-h', '--help', 'Usage help') do
      puts op.to_s
      exit
    end
    op.separator ''

    op.parse!(argv)

    options
  end
end

def remove_repository_temp_dirs(shard, remove_flag = false)
  abort GEO_LICENSE_ERROR_TEXT unless Gitlab::Geo.license_allows?
  abort 'This is not a secondary node' unless Gitlab::Geo.secondary?

  unless Gitlab::Geo::ShardHealthCache.healthy_shard?(shard.name)
    puts "!!Shard named '#{shard.name}' is unhealthy, skipping: #{shard.path}"
    return
  end

  # Gitlab.config.repositories.storages.each do |name, repository_storage|
    # repo_root      = repository_storage.legacy_disk_path
    repo_root      = shard.path
    dir_pattern    = "*_#{'[[:xdigit:]]' * 14}.*git"
    null_seperator = "\u0000"

    puts "\nScanning shard '#{shard.name}' : #{repo_root} ..."

    # old-style temp directories end with an underscore followed by a 14 character hex number
    IO.popen(%W(find #{repo_root} -mindepth 1 -type d -name #{dir_pattern} -print0)) do |find|
      find.each_line(null_seperator) do |path|
        path.chomp!(null_seperator)
        repo_with_namespace = path
          .sub(repo_root, '')
          .sub(%r{^/*}, '')
          .chomp('.git')
          .chomp('.wiki')

        next unless repo_with_namespace =~ /_[[:xdigit:]]{14}\z/
        next if repo_with_namespace.start_with?("#{IGNORABLE_NAMESPACE_PREFIX}")
        next if Project.where_full_path_in([repo_with_namespace]).exists?
        next if File.file?(path)

        if remove_flag
          if FileUtils.remove_dir(path)
            puts "Removed...#{path}"
          else
            puts "Cannot remove #{path}"
          end
        else
          puts "Can be removed: #{path}"
        end
      end
    end
  # end
end

def list_shards
  shards = StorageShard.all

  shards.each do |shard|
    health = Gitlab::Geo::ShardHealthCache.healthy_shard?(shard.name) ? 'Healthy  ' : 'Unhealthy'
    puts "#{health} : #{shard.name} : #{shard.path}"
  end

  exit
end

if $0 == __FILE__
  options = UtilityOptionParser.parse(ARGV)

  # We load rails environment / initializers only here to get faster command line startup when `--help` and `--version`
  puts "Loading Rails..."
  require "#{options[:rails_root]}/config/environment"

  list_shards if options[:list_shards]

  shards = StorageShard.all

  if options[:shard]
    shards.select! { |shard| shard.name == options[:shard] }
    abort "Shard named '#{options[:shard]}' does not exist" if shards.empty?
  else
    shards.uniq! { |shard| shard.path }
  end

  puts "Will perform a #{options[:remove] ? 'DELETION' : 'DRYRUN'}..."
  shards.each do |shard|
    remove_repository_temp_dirs(shard, options[:remove])
  end
end
